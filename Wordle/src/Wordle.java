import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

public class Wordle {
    private ArrayList<String> knownWords = new ArrayList<>();
    private String secretWord;
    private Random rnd = new Random(); // a source of random numbers

    /**
     * Create a new Wordle game, loading allowable words from a file.
     * See comments on loadWords() for the file format.
     *
     * @param file    - the file from which to load 'known words'
     * @param length  - the minimum length word
     * @param minfreq - the minimum allowed frequency
     * @param maxfreq - the maximum allowed frequency
     */
    public Wordle(String file, int length, long minfreq, long maxfreq) throws IOException {
        // ~12K 5 letter words with min frequency of 100,000
        loadWords(file, length, minfreq, maxfreq);
    }

    /**
     * _Part 1: Implement this constructor._
     * Load known words from the array that is supplied.
     * @param words - an array of words to load
     */
    public Wordle(String[] words) {
        int l = words[0].length();
        for (int i = 0; i < words.length; i++) {
            if (words[i].length() == l) knownWords.add(words[i].toLowerCase());
        }
    }
    public String getSecretWord() {
        return secretWord;
    }
    public int numberOfKnownWords() {
        return knownWords.size();
    }

    /**
     * _Part 2: Implement this method._
     *
     * Scans a file with filenm that contains words and their corresponding frequency.
     * If the word is the specified length and frequency range,
     * Then add it to knownWords.
     *
     * @param filenm  - the file name to load from
     * @param length  - the length of words we want to load (e.g., 5 to load 5 character words)
     * @param minfreq - the minimum allowable frequency for a loaded word
     * @param maxfreq - the maximum allowable frequenct for a loaded word; 0 indicates no maximum
     */
    public void loadWords(String filenm, int length, long minfreq, long maxfreq) throws IOException {
        Scanner scan = new Scanner(new File(filenm));
        while (scan.hasNext() == true) {
            String s = scan.next();
            long freq = scan.nextLong();
            if (freq < minfreq) break; // Assuming that frequency in file is ordered
            if (s.length() == length && freq >= minfreq && (freq <= maxfreq || maxfreq == 0)) {
                knownWords.add(s.toLowerCase());
            }
        }
    }

    /**
     * _Part 3: Implement this method._
     *
     * Obtain a list of known words. This method creates a new copy of the known words list.
     *
     * @return a new copy of list of known words.
     */
    public ArrayList<String> getKnownWords() {
        ArrayList<String> copy = new ArrayList<>();
        for (String knownWord : knownWords) {
            copy.add(knownWord);
        }
        return copy;
    }

    /**
     * Prepare the game for playing by choosing a new secret word.
     */
    public void initGame() {
        Random r = new Random();
        secretWord = knownWords.get(r.nextInt(knownWords.size()));
    }

    /**
     * Supply a guess and get a hint!
     *
     * @param g - the guess (a string which is the same length as the secret word)
     * @return a hint indicating the letters guessed correctly/incorrectly
     * @throws IllegalArgumentException if the guess is not the same length as the secret word
     */
    public Hint guess(String g) {
        int length = secretWord.length();
        if (length != g.length()) {
            throw new IllegalArgumentException("Wrong length guess!");
        }
        return new Hint(g, secretWord);
    }
}

class Hint {
    // why private?
    // because we want the hint to be generated by the constructor and then
    // not messed with further. So, we restrict access to these variables.
    private String correctlyPlaced = "";
    private String incorrectlyPlaced = "";
    private String notInPuzzle = "";
    private String guess;

    /**
     * _Part 4: Implement this Constructor._
     *
     * I used the concatenation method because of how I planned to tackle the problem.
     * I wanted to read each character of guess in order, starting from the first index.
     * It was simpler to just add "-" or the character to the end of correctlyPLaced and incorrectlyPLaced
     * As I read through each character in guess.
     *
     * @param guess
     * @param secretWord
     */
    public Hint(String guess, String secretWord) {
        guess = guess.toLowerCase();
        this.guess = guess;
        // Determines correctlyPlaced
        for (int i=0; i < secretWord.length(); i++) {
            char c = guess.charAt(i);
            if (c == secretWord.charAt(i)) {
                correctlyPlaced += secretWord.charAt(i);
            } else {
                correctlyPlaced += "-";
            }
        }
        // Determines incorrectlyPlaced
        for (int i=0; i < secretWord.length(); i++) {
            char c = guess.charAt(i);
            int charsInIncorrect = numberOfChars(incorrectlyPlaced, c);
            int charsInCorrect = numberOfChars(correctlyPlaced, c);
            int charsInSecret = numberOfChars(secretWord, c);
            // Checks for non-redundant characters to add to incorrectlyPlaced
            // All redundant characters are ignored, hence will be added to notInPuzzle
            if (charsInIncorrect+charsInCorrect < charsInSecret && correctlyPlaced.charAt(i) != c) {
                incorrectlyPlaced += guess.charAt(i);
            } else {
                incorrectlyPlaced += "-";
            }
        }
        // Determines notInPuzzle
        for (int i=0; i < secretWord.length(); i++) {
            char c = guess.charAt(i);
            // If this spot is not correctlyPlaced and not incorrectlyPlaced
            if (correctlyPlaced.charAt(i) == '-' && incorrectlyPlaced.charAt(i) == '-') {
                notInPuzzle += c;
            }
        }
    }
    public int numberOfChars(String word, char c) {
        int count = 0;
        for (int i=0; i < word.length(); i++) {
            if (word.charAt(i) == c) count++;
        }
        return count;
    }
    public boolean isWin() {
        // true iff the '-' isn't in the correctlyPlaced String...
        return (correctlyPlaced.indexOf('-') == -1);
    }

    /**
     * Display a hint on System.out
     *
     * Given a secret word: 'state', and a guess 'scope' display:
     *
     * ---- Hint (scope) ----
     * Correctly placed  : s---e
     * Incorrectly placed: -----
     * Not in the puzzle : [cop]
     *
     * Given a secret word: 'state', and a guess 'sttae' display:
     *
     * ---- Hint (scope) ----
     * Correctly placed  : st--e
     * Incorrectly placed: --ta-
     * Not in the puzzle : []
     */
    public void write() {
        System.out.println("---- Hint (" + guess + ") ----");
        System.out.println("Correctly placed  : " + correctlyPlaced);
        System.out.println("Incorrectly placed: " + incorrectlyPlaced);
        System.out.println("Not in the puzzle : [" + notInPuzzle + "]");
    }

    /**
     * Note that we can return a reference to the correctlyPlaced String
     * safely since String's aren't immutable.  Thus, someone that messes
     * with the result we return won't actually impact the String
     * referenced by the Hint itself...
     *
     * @return the correctly placed portion of the hint
     */
    public String getCorrectlyPlaced() {
        return correctlyPlaced;
    }

    /**
     *
     * @return the incorrectly placed portion of the hint
     */
    public String getIncorrectlyPlaced() {
        return incorrectlyPlaced;
    }

    /**
     *
     * @return the not-in-puzzle portion of the hint
     */
    public String getNotInPuzzle() {
        return notInPuzzle;
    }
}
